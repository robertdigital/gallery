
### TypeScript

As of Smartdown v1.0.20, the Smartdown engine is being reconstructed using [Typescript](). As of v1.0.21, Smartdown supports the dynamic compilation of Typescript in the browser via `typescript` playables.

References:
- [Using the Compiler API](https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API)

#### A Typescript Playable

For our first example, we'll create a little `typescript` playable that just listens for changes to the `Name` variable and adjusts its `div` content accordingly. We'll use the `/debug` qualifier on the playable to allow us to view the augmented code that will transpile typescript into javascript.

The source for this playable is encoded in Smartdown like this:

````markdown
```javascript /typescript/playable/autoplay/debug
  // SOURCE goes here
```
````

with `// SOURCE goes here` being replaced by:

```javascript /typescript
const myDiv = this.div;
myDiv.style.background = 'lavender !important';
myDiv.style.color = 'magenta !important';
myDiv.style.padding = '10px 2px';
myDiv.style.margin = '10px 2px';

this.dependOn = ['Name'];
this.depend = function(): void {
  const msg: string = ['Nice', 'to', 'meet', 'you'].join(' ');

  myDiv.innerHTML = `<p>${msg}, <b>${env.Name}</b>!</p>`;
};

```

---

[What is your name?](:?Name)

```javascript /typescript/playable/autoplay/debug
const myDiv = this.div;
myDiv.style.background = 'lavender !important';
myDiv.style.color = 'magenta !important';
myDiv.style.padding = '10px 2px';
myDiv.style.margin = '10px 2px';

this.dependOn = ['Name'];
this.depend = function(): void {
  const msg: string = ['Nice', 'to', 'meet', 'you'].join(' ');

  myDiv.innerHTML = `<p>${msg}, <b>${env.Name}</b>!</p>`;
};
```

#### Detecting source errors with the playable's console

The augmented code that Smartdown generates around Typescript to transpile it to Javascript has been recently (v1.0.24) improved so that syntax errors detected during transpilation are reported via the Smartdown per-playable console, which is a new feature (see [Javascript](:@Javascript)).

Let's give this feature a try by creating a TypeScript playable that is *syntactically* incorrect because it lacks a closing single quote on a string declaration. This playable is NOT autoplay, so you will need to click the `Play` button to see stuff happen:

```javascript /typescript/playable
const msg: string = 'I better not forget the closing quote...;
this.div.innerHTML = `<h1>${msg}</h1`;

```


#### Invoking the TypeScript Transpiler Explicitly

Before Smartdown had a proper `typescript` playable language type, I prototyped the capability by using an ordinary Javascript playable and then using `smartdown.import` to dynamically load the TypeScript compiler via the [jsDelivr]() CDN, followed by transpiling some example source and then generating a `Function` and invoking it with the current playable's context. For the most part, the following playable is patterned after the *augmented code* generated by Smartdown when processing a Typescript playable.

---

[String to uppercase](:?String)
[Uppercased String](:!StringUpper)

```javascript /playable
//smartdown.import=https://cdn.jsdelivr.net/npm/typescript/lib/typescript.min.js

const source =
`
this.dependOn = ['String'];
this.depend = function() {
  const upper: string = env.String.toUpperCase();
  smartdown.setVariable('StringUpper', upper);
}
`;


// https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#transpiling-a-single-file
  // compilerOptions?: CompilerOptions;
  // fileName?: string;
  // reportDiagnostics?: boolean;
  // moduleName?: string;
  // renamedDependencies?: Map<string>;

let result = ts.transpileModule(source, {
  compilerOptions: {
    module: ts.ModuleKind.CommonJS,
    target: 'es6',
    allowJs: true,
    checkJs: true,
  },
  reportDiagnostics: true,
});

if (result.diagnostics.length > 0) {
  console.log('result.diagnostics');
  console.log(result.diagnostics);
}

smartdown.runFunction(
  result.outputText,
  this,
  [...arguments],
  playable.language,
  this.div);

```

##### Using `await` without a wrapper.

As of SD v1.0.25, Javascript playable sources are wrapped with an `async` function wrapper so that `await` can be used within the source of the playable. This is exercised in a [Javascript](:@Javascript) example, but let's make sure it works with TypeScript.

```javascript /typescript/playable
console.log('Hello from the typescript playable');
const response: any = await fetch('https://unpkg.com/smartdown/package.json');
const myJson: any = await response.json();
smartdown.setVariable('Package', myJson);
```

[package.json](:!Package|json)


---

[Back to Home](:@Home)
